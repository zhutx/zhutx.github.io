<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设备端接口协议]]></title>
    <url>%2F2018%2F05%2F31%2Fguuin%2F%E8%AE%BE%E5%A4%87%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[终端接口协议生成二维码串 接口地址 123POST：$&#123;device-interface&#125;/active/genQrCodeBody：raw JSON(application/json) 请求JSON示例 1234&#123; "deviceSn": "0000000001", "qrCodeType": 1&#125; 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || ———- | ———- | —— | —- | —————— | —- || deviceSn | 设备序列号 | string | | | || qrCodeType | 二维码类型 | int | | 参见常量QrCodeType | | 返回JSON示例 1234567891011&#123; "result": "0", "message": "操作成功", "data": &#123; "deviceSn": "0000000001", "qrCodeType": 1, "qrCode": "g5fjv3ts94o6m8gj0nqd89kj9sal4hk3", "url": "http://fish.guuin.com:8004/device/activeForward?qrCode=g5fjv3ts94o6m8gj0nqd89kj9sal4hk3", "status": 0 &#125;&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || ———- | ———— | —— | ——————– | —- || deviceSn | 设备序列号 | string | | || qrCodeType | 二维码类型 | int | 参见常量QrCodeType | || qrCode | 二维码串号 | string | | || url | 扫码请求地址 | string | | || status | 二维码状态 | int | 参见常量QrCodeStatus | | 其他备注 ​ 获取激活状态 接口地址 1GET：$&#123;device-interface&#125;/active/state?qrCode=l0s41gthggj85qlolvh1g0b9riam3oip 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || —— | ———- | —— | —- | —- | —- || qrCode | 二维码串号 | string | | | | 返回JSON示例 123456789&#123; "result": "0", "message": "操作成功", "data": &#123; "deviceSn": "0000000001", "qrCodeStatus": 0, "communicationKey": "riv91qu2krdl2fnp377knto5it" &#125;&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —————- | ———- | —— | ——————– | —————— || deviceSn | 设备序列号 | string | | || qrCodeStatus | 二维码状态 | int | 参见常量QrCodeStatus | || communicationKey | 通信密钥 | string | | 后续在header中携带 | 其他备注 ​ 获取初始化数据 接口地址 1GET：$&#123;device-interface&#125;/biz/initData?deviceSn=0000000001 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || ——– | ———- | —— | —- | —- | —- || deviceSn | 设备序列号 | string | | | | 返回JSON示例 123456789101112131415161718192021222324252627282930&#123; "result": "0", "message": "操作成功", "data": &#123; "orgInfo": &#123; "orgId": "1599452409510232064", "orgName": "测试机构2", "provCode": 330001, "cityCode": 330101, "districtCode": 330111, "streetCode": 330110002, "address": "address2", "contact": "contact2", "phone": "888888882", "memo": "memo2", "logoUrl": "http://image.guuin.com/logo/2018/5/8/12/d702429d741740c7817561b853e37fb8.jpg", "status": 1, "gmtCreate": 1525356685013, "gmtModify": 1525752683417 &#125;, "faceStandardInfo": &#123; "quality": 0.8, "rollAngle": 20, "pitchAngle": 20, "yawAngle": 20, "faceWidth": 20, "faceHeight": 20 &#125; &#125;&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || ————————— | ———— | —— | —————– | —- || orgInfo.orgId | 机构id | long | | || orgInfo.orgName | 机构名 | string | | || orgInfo.provCode | 省编号 | int | | || orgInfo.cityCode | 市编号 | int | | || orgInfo.districtCode | 区编号 | int | | || orgInfo.streetCode | 街道编号 | int | | || orgInfo.address | 地址 | string | | || orgInfo.contact | 负责人 | string | | || orgInfo.phone | 电话 | string | | || orgInfo.memo | 备注 | string | | || orgInfo.logoUrl | logo地址 | string | | || orgInfo.status | 状态 | int | 参见常量OrgStatus | || faceStandardInfo.quality | 人脸质量 | float | | || faceStandardInfo.rollAngle | 左右歪头角度 | float | | || faceStandardInfo.pitchAngle | 抬头低头角度 | float | | || faceStandardInfo.yawAngle | 左右转头角度 | float | | || faceStandardInfo.faceWidth | 人脸宽度 | float | | || faceStandardInfo.faceHeight | 人脸高度 | float | | | 其他备注 人脸识别 接口地址 123POST：$&#123;device-interface&#125;/verify/imagesBody：form-data 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || ——– | ———- | —— | —- | —- | ———- || deviceSn | 设备序列号 | string | | | || images | 人脸图片 | File | | | 支持多图片 | 返回JSON示例 12345&#123; "result": "0", "message": "操作成功", "data": []&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —— | ——– | —- | —- | —- || | | | | | 其他备注 获取验证码 接口地址 1GET：$&#123;device-interface&#125;/faceEnter/checkCode?mobile=15088668850 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || —— | ——– | —— | —- | —- | —- || mobile | 手机号 | string | | | | 返回JSON示例 1234&#123; "result": "0", "message": "操作成功"&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —— | ——– | —- | —- | —- || | | | | | 其他备注 验证合法性 接口地址 1GET：$&#123;device-interface&#125;/faceEnter/checkValid?orgId=1599452409510232064&amp;mobile=15088668850&amp;checkCode=5509 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || ——— | ——– | —— | —- | —- | —- || orgId | 机构id | long | | | || mobile | 手机号 | string | | | || checkCode | 验证码 | string | | | | 返回JSON示例 1234&#123; "result": "0", "message": "操作成功"&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —— | ——– | —- | —- | —- || | | | | | 其他备注 获取人员信息 接口地址 1GET：$&#123;device-interface&#125;/faceEnter/person?orgId=1599452409510232064&amp;mobile=15088668850 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || —— | ——– | —— | —- | —- | —- || orgId | 机构id | long | | | || mobile | 手机号 | string | | | | 返回JSON示例 1234567891011121314151617&#123; "result": "0", "message": "操作成功", "data": &#123; "personId": "1600674989130907648", "orgId": "1599452409510232064", "personType": 1, "personName": "朱田祥", "nickName": "小朱", "faceEnterFlag": 1, "verifyFaceUrl": "http://image.guuin.com/verifyFace/2018/5/21/22/c54cb509876d4bac834316b6b7874390.jpg", "mobile": "15088668850", "status": 1, "gmtCreate": 1526522633215, "gmtModify": 1526913763215 &#125;&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || ————- | ———— | —— | ——————– | —- || personId | 人员id | long | | || orgId | 机构id | long | | || personType | 人员类型 | int | 参见常量PersonType | || personName | 姓名 | string | | || nickName | 昵称 | string | | || faceEnterFlag | 人脸是否已录 | int | 参见常量YesNoFlag | || verifyFaceUrl | 识别照片url | string | | || mobile | 手机号 | string | | || status | 状态 | int | 参见常量PersonStatus | | 其他备注 上传临时图片 接口地址 123POST：$&#123;device-interface&#125;/faceEnter/uploadTempPicBody：form-data 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || —— | ——– | —- | —- | —- | —- || image | 人脸图片 | File | | | | 返回JSON示例 12345&#123; "result": "0", "message": "操作成功", "data": "http://image.guuin.com/temporary/2018/5/21/22/0543c5cbca9a4994a403b91ef9fd770a.jpg"&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —— | ——– | —— | —- | —- || data | 图片URL | string | | | 其他备注 修改识别照片 接口地址 123POST：$&#123;device-interface&#125;/faceEnter/updateVerifyFaceUrlBody：raw JSON(application/json) 请求JSON示例 12345&#123; "orgId": 1599452409510232064, "personId": 1600674989130907648, "verifyFaceUrl": "http://image.guuin.com/temporary/2018/5/21/22/0543c5cbca9a4994a403b91ef9fd770a.jpg"&#125; 请求参数 | 参数名 | 参数描述 | 类型 | 长度 | 值阈 | 说明 || ————- | ———– | —— | —- | —- | —- || orgId | 机构id | long | | | || personId | 人员id | long | | | || verifyFaceUrl | 识别照片url | string | | | | 返回JSON示例 1234&#123; "result": "0", "message": "操作成功"&#125; 返回参数 | 参数名 | 参数描述 | 类型 | 值阈 | 说明 || —— | ——– | —- | —- | —- || | | | | | 其他备注 参考常量表 常量字段 常量说明 常量值 YesNoFlag 是或否标识 0-否1-是 QrCodeType 二维码串类型 0-管理1-激活2-开门3-录脸 QrCodeStatus 二维码串状态 -1-已失效 0-新生成 1-已扫码 2-已激活 OrgStatus 机构状态 0-停用1-可用 PersonType 人员类型 1-成员2-访客 PersonStatus 人员状态 0-停用1-可用2-删除]]></content>
      <categories>
        <category>guuin</category>
      </categories>
      <tags>
        <tag>guuin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ（一）HelloWorld]]></title>
    <url>%2F2018%2F04%2F17%2Frabbitmq%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[消息队列，用来解耦系统模块。RabbitMQ完全实现了AMQ标准，与Kafka的快快快不同，它追求稳定、可靠。下面的介绍内容借鉴至RabbitMQ的官方文档。 RabbitMQ是一个消息的中介，就像是一个非常可靠的邮局，当信件放到邮局时，信件就确保能到达。 基础知识 producer（生产者）生产数据 queue（队列）存储消息，类似于邮箱 Consumer（消费者）接收并消费消息 HelloWorld示例下面我们用最简单的示例，完成消息的生产和消费： 引入Maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 消息发送者： 123456789101112131415161718192021222324252627282930import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Send &#123; private final static String QUEUE_NAME = "hello"; public static void main(String[] args) throws Exception &#123; // 通过ConnectionFactory产生一个新的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); // 创建Channel 消息的产生和发送都是通过Channel完成的 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发布消息 String message = "Hello World"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes("UTF-8")); System.out.println(" [x] Sent '"+ message +"'"); // 最后要关闭Channel channel.close(); connection.close(); &#125;&#125; 消息接受者： 123456789101112131415161718192021222324252627282930313233343536import com.rabbitmq.client.*;import java.io.IOException;public class Rece &#123; private final static String QUEUE_NAME = "hello"; public static void main(String[] argv) throws Exception &#123; // 通过ConnectionFactory产生一个新的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); // 创建Channel 消息的产生和发送都是通过Channel完成的 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); // 消息的发送是异步的，提供回调方法 // DefaultConsumer会暂存异步消息, 直到消费者有能力来消费它 Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println(" [x] Received '" + message + "'"); &#125; &#125;; // 消费队列 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 跑起来 需要在生产者之前启动消费者，确保在消费消息之前这个队列是已经存在的 编译： 1javac -cp amqp-client-4.0.2.jar Send.java Recv.java 而后来运行它，这需要我们在路径加上它的依赖包，我们首先启动的是消费者： 1java -cp .:amqp-client-4.0.2.jar:slf4j-api-1.7.21.jar:slf4j-simple-1.7.22.jar Recv 而后启动发送者： 1java -cp .:amqp-client-4.0.2.jar:slf4j-api-1.7.21.jar:slf4j-simple-1.7.22.jar Send 消费者会持续等待，并打印从生产者哪里来的消息，你可以用(Ctrl-C)来停止它。所以你要另外开启一个命令行窗口来运行生产者。 查看队列也许你想知道RabbitMQ中到底有多少个消息，你可以使用rabbitmqctl工具： 1sudo rabbitmqctl list_queues]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ（三）交换机]]></title>
    <url>%2F2018%2F04%2F17%2Frabbitmq%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[什么是交换机rabbitmq的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。是append到一定规则的queue，还是append到多个queue中，还是被丢弃？这些规则都是通过exchagne的4种type去定义的。 exchange是一个消息的agent，每一个虚拟的host中都有定义。它的职责是把message路由到不同的queue中。 binding exchange和queue通过routing-key关联，这两者之间的关系是就是binding。如下图所示,X表示交换机，红色表示队列，交换机通过一个routing-key去binding一个queue。 交换机类型 Default Exchange（默认交换机） Fanout Exchange（广播交换机） Directed Exchange（直连交换机） Topic Exchange（主题交换机） 默认交换机在前面的章节中虽然没有设置任何交换机，但依然能够将消息发送到队列，这是因为使用了默认交换机： 1channel.basicPublish("", QUEUE_NAME, null, message.getBytes("UTF-8")); 第一个参数exhange为空字符串，即采用默认交换机，第二个参数routingKey定义了绑定的队列。 广播交换机为了更好的阐述这个模式，我们会建立一个简单的logging系统，包含2个步骤-第一步发送log信息，第二步能够接受并将信息打印出来，而且在第二步中所有的消费者都会接受到同样的消息，比如一个消费者用来将log信息写到磁盘，另外一个接受信息并显示在屏幕上。因此一旦有有消息，消息会广播到所有的消费者。 生产者侧的变化 使用广播交换机模式： 1channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); 广播模式无需进行队列的路由，会忽略routingKey，因此写空字符串即可： 1channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8")); 消费者侧的变化 使用广播交换机模式： 1channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); 临时队列 我们之前队列都有名字（Hello队列和task_queue队列)，给队列起名字非常重要-需要将消费者绑定到特定的queue上面，以及需要把消息从生产者发送给特定的消费者。 但对于日志来说，消息会发送到所有的消费者，而并非个别，为了满足当前需求我们用RabbitMQ随机分配队列，比如amq.gen-JzTY20BRgKO-HjmUJj0wLg： 123# 定义一个不需要持久化、独立的、能够被自动删除的队列String queueName = channel.queueDeclare().getQueue();channel.queueBind(queueName, EXCHANGE_NAME, ""); 交换机和队列绑定 我们已经声明了一个广播交换机，现在需要告诉这个交换机需要把信息发送给哪些队列，交换机和队列间的这个关系就称之为绑定： 12# 广播模式无需进行队列的路由，会忽略routingKey，因此写空字符串即可channel.queueBind(queueName, EXCHANGE_NAME, ""); 整合 生产者示例： 1234567891011121314151617181920212223242526272829303132333435363738public class EmitLog &#123; private static final String EXCHANGE_NAME = "logs"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String message = getMessage(argv); channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8")); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125; private static String getMessage(String[] strings)&#123; if (strings.length &lt; 1) return "info: Hello World!"; return joinStrings(strings, " "); &#125; private static String joinStrings(String[] strings, String delimiter) &#123; int length = strings.length; if (length == 0) return ""; StringBuilder words = new StringBuilder(strings[0]); for (int i = 1; i &lt; length; i++) &#123; words.append(delimiter).append(strings[i]); &#125; return words.toString(); &#125;&#125; 消费者示例： 12345678910111213141516171819202122232425262728public class ReceiveLogs &#123; private static final String EXCHANGE_NAME = "logs"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, ""); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println(" [x] Received '" + message + "'"); &#125; &#125;; channel.basicConsume(queueName, true, consumer); &#125;&#125; 编译： 1javac -cp $CP EmitLog.java ReceiveLogs.java 如果你希望将log存储到本机上： 1java -cp $CP ReceiveLogs &gt; logs_from_rabbit.log 如果你希望在屏幕上显示log信息，打开一个新的终端： 1java -cp $CP ReceiveLogs 发送消息： 1java -cp $CP EmitLog 直达交换机上一节我们建立了一个简单的日志系统，从而将log消息广播给消费者。 现在我们希望通过log的严重程度进行过滤，例如只有严重的错误才会写入到磁盘，而warn和info消息就不用了，以此来节省磁盘空间。而广播交换机没法满足这个需求，它只是无脑的发送消息。所以我们会使用直达交换机(Direct Exchange)- 消息会通过所绑定的键来发送给对应的队列。 如上图所示，直达交换机X绑定了两个队列，C1是通过orange来绑定，而C2是通过black和green绑定。因此，发送到路由键orange的消息会发送给队列Q1，发送到路由键black或者green的消息会发送给Q2，其它的消息将被丢弃。 多项绑定 当然，多个队列绑定到一个键上也是合法的，在这种情况下，直达交换机将会将消息发送给所有的队列，就像广播交换机一样，如上图所示，一个键为black的消息将会同时被发送给C1和C2。 首先生产者这一侧，需要创建一个直达交换机： 1channel.exchangeDeclare(EXCHANGE_NAME, "direct"); 并发送消息到这个交换机： 1channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes()); 上面我们是发送给’severity’,简单起见，假设有下列几种日志类型’severity’ ,‘info’, ‘warning’, ‘error’。 消费者一侧，接受消息跟之前一样，但有一点不同，我们提供了一个binding key： 12345String queueName = channel.queueDeclare().getQueue();for(String severity : argv)&#123; channel.queueBind(queueName, EXCHANGE_NAME, severity);&#125; 整合 生产者示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class EmitLogDirect &#123; private static final String EXCHANGE_NAME = "direct_logs"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String severity = getSeverity(argv); String message = getMessage(argv); channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes("UTF-8")); System.out.println(" [x] Sent '" + severity + "':'" + message + "'"); channel.close(); connection.close(); &#125; private static String getSeverity(String[] strings)&#123; if (strings.length &lt; 1) return "info"; return strings[0]; &#125; private static String getMessage(String[] strings)&#123; if (strings.length &lt; 2) return "Hello World!"; return joinStrings(strings, " ", 1); &#125; private static String joinStrings(String[] strings, String delimiter, int startIndex) &#123; int length = strings.length; if (length == 0 ) return ""; if (length &lt; startIndex ) return ""; StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i &lt; length; i++) &#123; words.append(delimiter).append(strings[i]); &#125; return words.toString(); &#125;&#125; 消费者示例： 1234567891011121314151617181920212223242526272829303132333435public class ReceiveLogsDirect &#123; private static final String EXCHANGE_NAME = "direct_logs"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String queueName = channel.queueDeclare().getQueue(); if (argv.length &lt; 1)&#123; System.err.println("Usage: ReceiveLogsDirect [info] [warning] [error]"); System.exit(1); &#125; for(String severity : argv)&#123; channel.queueBind(queueName, EXCHANGE_NAME, severity); &#125; System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println(" [x] Received '" + envelope.getRoutingKey() + "':'" + message + "'"); &#125; &#125;; channel.basicConsume(queueName, true, consumer); &#125;&#125; 编译 1javac -cp $CP ReceiveLogsDirect.java EmitLogDirect.java 只保存warning和error的消息到磁盘上 1java -cp $CP ReceiveLogsDirect warning error &gt; logs_from_rabbit.log 将所有的消息打印到频幕上 12java -cp $CP ReceiveLogsDirect info warning error# =&gt; [*] Waiting for logs. To exit press CTRL+C 最后，发送error消息 12java -cp $CP EmitLogDirect error "Run. Run. Or it will explode."# =&gt; [x] Sent 'error':'Run. Run. Or it will explode.' 主题交换机在之前我们改进了日志系统。我们摒弃无脑发送消息的广播路由器，而使用能够根据绑定键(binding key)来发送消息的，从而能有有选择的后去logs. 尽管使用直达路由器大大的改进了我们系统，但也存在局限性:无法加入更多条件。比如我们希望能够加入更多的维度，我们希望不仅是基于严重程度，而且是基于来源，如果你对linux tool工具有了解的话，它不仅仅是基于严重程度(info/warn/crit…) 而且有来源(auth/cron/kern…)，会给我们更大的灵活性-我们需要监听所有来自’cron’的errors消息，以及来自’kern’的所有log。所以我们需要的是一个更复杂的主题交换机 主题交换机 发送到主题交换机的消息并不会有一个确定的路由键-而是一长串字符列表，以”.“来分割，而这个字符串列表表明了路由信息，比如”stock.usd.nyse”，“nyse.vmw”，“quick.orange.rabbit”，字符串的最大长度限制在255bytes。 同时，在队列绑定交换机时也需要指定模式，而符合模式的消息将会被发送至该队列，模式可以由通配符组成：‘*’ 可以表示一个词‘#’ 表示0个或多个词可以通过如下的例子来说明 请看例子，以发送动物的消息为例，我们会发送包含三个词的路由键(两个”.”)。第一个是速度，第二个是颜色，而第三个是种族 同时，我们建立了三个绑定，Q1绑定了键”.orange.“，Q2绑定了键”..rabbit”以及”lazy.#”。可以做如下的解释，Q1用来接受所有orange的动物，Q2用来接受所有rabbits，以及lazy的动物 一个路由为”quick.orange.rabbit”的消息将会被同时发送给这两个队列，消息”lazy.orange.elephant”也会被同时发给它们；”quick.orange.fox”只会发给第一个队列；”lazy.brown.fox”会发到第二个；”lazy.pink.rabbit”将只会发送给第二个;”quick.brown.fox”会被丢弃因为匹配不上任何一个。 如果我们发送四个词的呢？比如”oragne”或者”quick.orange.male.rabbit”?这些没有任何匹配的队列将会丢失。但比如”quick.orange.male.rabbit”会匹配到第二个队列。 主题交换机也可以当成其它交换机来使用，假如队列绑定到了 “#”,那么它会接收所有的消息，就像广播路由器一样；而如果未使用”*“,”#”，那么就跟直达路由器一样了。 整合代码 生产者示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class EmitLogTopic &#123; private static final String EXCHANGE_NAME = "topic_logs"; public static void main(String[] argv) &#123; Connection connection = null; Channel channel = null; try &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); connection = factory.newConnection(); channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String routingKey = getRouting(argv); String message = getMessage(argv); channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("UTF-8")); System.out.println(" [x] Sent '" + routingKey + "':'" + message + "'"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (Exception ignore) &#123;&#125; &#125; &#125; &#125; private static String getRouting(String[] strings)&#123; if (strings.length &lt; 1) return "anonymous.info"; return strings[0]; &#125; private static String getMessage(String[] strings)&#123; if (strings.length &lt; 2) return "Hello World!"; return joinStrings(strings, " ", 1); &#125; private static String joinStrings(String[] strings, String delimiter, int startIndex) &#123; int length = strings.length; if (length == 0 ) return ""; if (length &lt; startIndex ) return ""; StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i &lt; length; i++) &#123; words.append(delimiter).append(strings[i]); &#125; return words.toString(); &#125;&#125; 消费者示例： 123456789101112131415161718192021222324252627282930313233343536public class ReceiveLogsTopic &#123; private static final String EXCHANGE_NAME = "topic_logs"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String queueName = channel.queueDeclare().getQueue(); if (argv.length &lt; 1) &#123; System.err.println("Usage: ReceiveLogsTopic [binding_key]..."); System.exit(1); &#125; for (String bindingKey : argv) &#123; channel.queueBind(queueName, EXCHANGE_NAME, bindingKey); &#125; System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println(" [x] Received '" + envelope.getRoutingKey() + "':'" + message + "'"); &#125; &#125;; channel.basicConsume(queueName, true, consumer); &#125;&#125;]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ（四）运维相关]]></title>
    <url>%2F2018%2F04%2F17%2Frabbitmq%2F%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[查看队列也许你想知道RabbitMQ中到底有多少个消息，你可以使用rabbitmqctl工具： 1sudo rabbitmqctl list_queues 忘记应答很容易犯忘记应答的错误，但会导致非常严重的后果。Messages会被重发，RabbitMQ会消耗越来越多的内存因为unacked的消息无法释放（甚至更严重，RabbitMQ内部维护了一个最大打开线程数，如果太多的消息没有应答，RabbitMQ甚至会整个崩溃掉） 你可以用rabbitmqctl查看未被应答的消息数： 12sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ（二）任务队列]]></title>
    <url>%2F2018%2F04%2F17%2Frabbitmq%2F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言在上一节我们描述了最简单的RabbitMQ操作，如何发送、接受消息。在这一节中我们将描述如何创建一个任务队列，来将高耗时的任务分发到多个消费者，从而提高处理效率。 任务队列最主要的功能就是把高耗时的操作交给队列，让它延后再做。我们将任务封装成一个消息发送给队列，后台的任务进程会得到这个任务并执行它，而且可以配置多个任务进程，进一步加大吞吐率。 我们用Thread.sleep()来假装有个繁忙的操作，用”.”来表示需要停顿的秒数，比如一个叫Hello…的任务将停顿3秒钟： 消息确认为了确保消息不丢失，RabbitMQ支持消息确认。收到消息后消费者会给RabbitMQ服务器发送一个ack（我已经收到消息了），RabbitMQ就会在服务上删除这个消息了。 如果一个消费者挂了（连接关闭，channel关闭，或者是TCP连接丢失）而没有发送ack，RabbitMQ就会知道消息并没有消费成功，于是乎消息会被放到消息队列重新消费。如果此时还有其它消费者的话，消息会发送给其它消费者来消费，确保消息不会丢失。 123# 关闭自动ACK机制boolean autoAck = false;channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer); 12# 收到消息后主动方ACKchannel.basicAck(envelope.getDeliveryTag(), false); 忘记应答手动ack时，如忘记应答，导致unacked的消息无法释放，消息会一直被重发。（RabbitMQ内部维护了一个最大打开线程数，如果太多的消息没有应答，RabbitMQ甚至会崩溃） 12# 查看未应答消息数sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged 消息持久化光有ack应答机制还不够，RabbitMQ挂掉后，还是会丢失。因此我们还需要将消息持久化下来，当RabbitMQ重启时，队列以及消息也能够恢复。 123# 队列持久化boolean durable = true;channel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null); 123# 消息持久化AMQP.BasicProperties props = MessageProperties.PERSISTENT_TEXT_PLAIN;channel.basicPublish("", TASK_QUEUE_NAME, props, message.getBytes("UTF-8")); 公平分发当一个消费者非常耗时，而一个消费者非常快，由于消息都是公平的发送，所以它们都是接收到相同数量的消息，会导致一个消费者非常忙碌，而另外一个消费者非常空闲，而RabbitMQ无法得知这一点。 为了解决这个缺陷, 引入了basicQos方法以及prefetchCount =1的设置。这会告诉RabbitMQ一次只给消费者一个消息：如果这个消息未确认，将不会发送新的消息，从而它会将消息发送给其它并不那么忙的消费者。 12int prefetchCount = 1;channel.basicQos(prefetchCount); 整合代码 消息发送者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.IOException;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.Connection;import com.rabbitmq.client.Channel;import com.rabbitmq.client.MessageProperties;public class NewTask &#123; private static final String TASK_QUEUE_NAME = "task_queue"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); boolean durable = true; // 队列持久化 channel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null); String message = getMessage(argv); AMQP.BasicProperties props = MessageProperties.PERSISTENT_TEXT_PLAIN; // 消息持久化 channel.basicPublish("", TASK_QUEUE_NAME, props, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125; private static String getMessage(String[] strings)&#123; if (strings.length &lt; 1) return "Hello World!"; return joinStrings(strings, " "); &#125; private static String joinStrings(String[] strings, String delimiter) &#123; int length = strings.length; if (length == 0) return ""; StringBuilder words = new StringBuilder(strings[0]); for (int i = 1; i &lt; length; i++) &#123; words.append(delimiter).append(strings[i]); &#125; return words.toString(); &#125;&#125; 消息接收者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.rabbitmq.client.*;import java.io.IOException;public class Worker &#123; private static final String TASK_QUEUE_NAME = "task_queue"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); final Connection connection = factory.newConnection(); final Channel channel = connection.createChannel(); channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); int prefetchCount = 1; channel.basicQos(prefetchCount); // 打破公平分发 final Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println(" [x] Received '" + message + "'"); try &#123; doWork(message); &#125; finally &#123; System.out.println(" [x] Done"); // 给RabbitMQ服务器发送ack，确认消息已收到 channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125; &#125;; // 关闭自动消息确认机制, 消费者收到消息后需手动发给RabbitMQ服务器发ack boolean autoAck = false; channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer); &#125; private static void doWork(String task) &#123; for (char ch : task.toCharArray()) &#123; if (ch == '.') &#123; try &#123; Thread.sleep(1000); // 对每一个"."停顿1秒，假装很忙 &#125; catch (InterruptedException _ignored) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; &#125;&#125; 跑起来 首先，让我们同时运行两个工作线程，他们能够同时从队列获取消息。我们也需要同时开启3个console：1个生产者，2个消费者 消费者C1 123# shell 1java -cp $CP Worker# =&gt; [*] Waiting for messages. To exit press CTRL+C 消费者C2 123# shell 2java -cp $CP Worker# =&gt; [*] Waiting for messages. To exit press CTRL+C 让我们运行生产者 1234567891011# shell 3java -cp $CP NewTask# =&gt; First message.java -cp $CP NewTask# =&gt; Second message..java -cp $CP NewTask# =&gt; Third message...java -cp $CP NewTask# =&gt; Fourth message....java -cp $CP NewTask# =&gt; Fifth message..... 让我们看看消费者们消费者C1 12345java -cp $CP Worker# =&gt; [*] Waiting for messages. To exit press CTRL+C# =&gt; [x] Received 'First message.'# =&gt; [x] Received 'Third message...'# =&gt; [x] Received 'Fifth message.....' 消费者C2 1234java -cp $CP Worker# =&gt; [*] Waiting for messages. To exit press CTRL+C# =&gt; [x] Received 'Second message..'# =&gt; [x] Received 'Fourth message..]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）React技术栈一览]]></title>
    <url>%2F2018%2F04%2F15%2Freact-redux%2FReact%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[从上面搭建工程脚手架中，我们看到了React开发技术栈。有ES6、babel、eslint、webpack、react、redux、react-router。 对React新手（有HTML、JavaScript、CSS基础）来说，需明确掌握React和Redux相关概念。至于其他的，了解就可以。不过我们有必要在实践之前从整体上俯瞰一下。清楚来龙去脉，避免迷迷糊糊一味跟随别人的代码去Ctrl+C &amp; Ctrl+V，即痛苦又容易半途而废。 ES6JavaScript的下一代标准，规定今后按年份发布新版。2015年发布的ECMAScript6.0，也叫ES2015。实践React之前，建议先了解下ES6的模块化、箭头函数、表达式解构、Promise异步编程。 完整了解ES6，推荐阅读前端大牛Nicholas C. Zakas（尼古拉斯.泽卡斯）的《深入理解ES6》 线上阅读推荐：阮一峰的开源书《ECMAScript6入门》 BabelJavaScript在不断发展，各种新的标准提案层出不穷，由于浏览器的多样性导致可能几年之内都无法广泛普及。Babel是一个广泛使用的转码器，可以将ES6代码转化为几乎所有浏览器都认识的ES5旧代码，你可以不必顾虑的使用ES新特性。 这里有个Babel的REPL线上编译器。在左侧输入箭头函数f=&gt;f感受下吧。 实践React之前，知道有这么个东西就可以了。Webpack会在构建项目时自动调用Babel进行转换。 线上阅读推荐：React技术栈之Babel ESlintESLint是一个JavaScript代码静态检查工具，可以有效提高代码质量。维持前端团队高度一致的编码风格。ESLint不但提供一些默认的规则，也提供用户自定义规则去约束JavaScript风格。 ESLint是Nicholas C. Zakas（尼古拉斯.泽卡斯）创造的。前端大牛，前雅虎前端技术主管，YUI 库的贡献者。当年的我，凭着他的红宝书《JavaScript高级程序设计》，再配合《CSS网站布局实录》，就迈入前端。他同时也是《编写可维护的JavaScript》、《高性能JavaScript》和《深入理解ES6》的作者。 实践React之前，知道有这么个东西就可以了。项目过程中，需要调整规则的时候，参考ESlint完整规则列表 WebpackWebpack是新一代打包工具。如今，前端项目日渐复杂，构建系统已成为开发过程中不可或缺的部分，而模块打包正是前端构建系统的核心。 实践React之前，了解下webpack就可以。通过ceate-react-app创建的脚手架，执行npm run eject弹出的webpack配置，就已经相当完美了。再集合项目，适当定制就可以了。 线上阅读推荐：入门webpack一小时包教会webpack 线上阅读推荐：React技术栈之Webpack环境搭建（一）手动搭建React技术栈之Webpack环境搭建（二）不同环境不同配置React技术栈之Webpack环境搭建（三）打包性能优化 ReactReact是Facebook推出的JavaScript库。口号是“用来创建用户界面的JavaScript库”，所以它只是和用户界面打交道，可以把它看成MVC中的V（视图）层，项目中一般再配上Redux进行数据流和状态的管理。 实践React之前，强烈建议熟悉下React概念。 线上阅读推荐：React技术栈之React（一）初识ReactReact技术栈之React（二）组件的prop和stateReact技术栈之React（三）组件的生命周期 ReduxReact的核心就是组件，它只负责view，当应用复杂程度增加时，还需要有数据流向控制、状态管理等方案。 React推出了Flux架构及其官方实现。同时业界也推出了很多Flux的实现，其中以Redux为翘楚，它将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 直接使用Redux是有点烦的，因此React官方提供了react-redux库，它对redux api进行了封装，借助react-redux，可以在项目中更方便的使用Redux。 实践React之前，必须熟悉Redux和react-redux，了解Flex架构更好但不是必须。 线上阅读推荐：Redux入门教程React技术栈之Redux异步流React技术栈之Redux高阶运用 react-router路由库React-Router，是React体系的一个重要部分。它是官方维护的，事实上也是唯一可选的路由库。它通过管理URL，实现组件的切换和状态的变化。现在已经到了react-router4版本了，跟3版本用法有所不同。 实践React之前，可以了解下。 线上阅读参考：React技术栈之React-Router(这个是react-router3) UI框架诸如 Ant Design、Material-UI、React bootstrap、React Desktop、Amaze UI React]]></content>
      <categories>
        <category>React+Redux开发实录</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）搭建工程脚手架]]></title>
    <url>%2F2018%2F04%2F15%2Freact-redux%2F%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[准备工作 安装node 安装git 安装一款前端IDE推荐VSCode，最火的前端IDE，比sublime开源，比WebStrom轻，比XCode快。人性化，配色也很舒服，用来开发很惬意。 create-react-app基础脚手架借助React官方的create-react-app工具，开发人员可以从配置工作中解脱出来，无需过早关注React技术栈，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发： 1$ npm install -g create-react-app 安装结束后，就可以在终端用create-react-app命令创建工程： 1$ create-react-app react-redux-app react-redux-app工程集成了react应用框架，在此基础上进行React应用开发，就避免了繁琐的初始配置工作。 进入工程目录，启动工程： 12$ cd react-redux-app$ npm start 启动了一个开发模式的服务器，指向本机http://localhost:3000/，显示如下： 弹出webpack配置实际开发中，通常要定制webpack的配置，因此我们弹出应用的webpack配置： 1$ npm run eject 执行完以上命令，react-redux-app下多了config和scrips目录，分别对应webpack配置和npm脚本。 安装redux相关库安装redux核心库： 1$ npm install redux --save 直接使用redux的API会比较繁琐。react官方提供的react-redux库，可以更方便的使用redux： 1$ npm install react-redux --save 安装babel插件transform-decorators-legacy，可以使用@connect更方便的连接UI组件与容器组件： 1$ npm install babel-plugin-transform-decorators-legacy --save-dev 安装transform-decorators-legacy插件后，需在package.json配置该插件： 12345"babel": &#123; "plugins": [ "transform-decorators-legacy" ]&#125; 安装下redux异步调用的库redux-thunk：1$ npm install redux-thunk --save 其他配套库12345678910# 路由库react-router4$ npm install react-router-dom --save# ajax库$ npm install axios --save# 组件属性校验库$ npm install prop-types --save# cookie操纵库$ npm install browser-cookies --save# socket.io客户端$ npm install socket.io-client --save 配置下代理开发中，前端工程与后端API不在一个域名，为避免跨域限制，方便接口调试，需在package.json中配下代理： 12# 比如，任何ajax请求，都代理到localhost:9093域"proxy": "http://localhost:9093" 来一款CSS预处理器less、sass或stylus都行，这里我安装less。1$ npm install less-loader less --save-dev 分别修改/config/webpack.config.dev.js和/config/webpack.config.prod.js：123456789&#123; test: /\.(css|less)$/, // 这里加上less use: [ ... &#123; loader: require.resolve('less-loader') // 配置less-loader &#125; ]&#125; 配合一款UI框架React开发，国内首选蚂蚁金服的antd设计，移动端的话，安装antd-mobile： 1$ npm install antd-mobile --save-dev 最好配置antd组件样式的按需加载，借助babel的import插件： 1$ npm install babel-plugin-import --save-dev package.json中，记得配置上该插件： 123456"babel": &#123; "plugins": [ "transform-decorators-legacy", ["import", &#123; "libraryName": "antd-mobile", "style": "css" &#125;] ]&#125; 初始目录文件创建一些初始目录和文件，在入口处完成redux和router的一些基础工作： 创建目录/src/component 创建目录/src/container 创建目录/src/redux 创建/src/container/login/index.js，编辑如下： 123456789import React from 'react'class Login extends React.Component &#123; render() &#123; return &lt;h2&gt;登录页&lt;/h2&gt; &#125;&#125;export default Login 创建/src/container/register/index.js，编辑如下： 123456789import React from 'react'class Register extends React.Component &#123; render() &#123; return &lt;h2&gt;注册页&lt;/h2&gt; &#125;&#125;export default Register 创建/src/config.js，编辑如下： 123456789101112import axios from 'axios'import &#123; Toast &#125; from 'antd-mobile'axios.interceptors.request.use(function(config) &#123; Toast.loading('加载中', 0) return config&#125;)axios.interceptors.response.use(function(config) &#123; Toast.hide() return config&#125;) 创建/src/reducer.js，编辑如下： 1234567import &#123; combineReducers &#125; from 'redux'function reducer(state = 0, action) &#123; return state&#125;export default combineReducers(&#123;reducer&#125;) 创建/src/app.js，编辑如下： 123456789101112131415161718import React from 'react'import &#123; Route &#125; from 'react-router-dom'import Login from './container/login'import Register from './container/register'class App extends React.Component &#123; render () &#123; return ( &lt;div&gt; &lt;Route path="/Register" component=&#123;Register&#125;&gt;&lt;/Route&gt; &lt;Route path="/login" component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;/div&gt; ) &#125;&#125;export default App 修改/src/index.js，编辑如下： 1234567891011121314151617181920212223242526import React from 'react';import ReactDOM from 'react-dom';import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import thunk from 'redux-thunk'import &#123; Provider &#125; from 'react-redux'import &#123; BrowserRouter &#125; from 'react-router-dom'import registerServiceWorker from './registerServiceWorker';import reducers from './reducer'import './config'import App from './app'registerServiceWorker()const store = createStore(reducers, compose( applyMiddleware(thunk), window.devToolsExtension ? window.devToolsExtension() : f =&gt; f))ReactDOM.render(( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;App&gt;&lt;/App&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt;), document.getElementById('root')); 删除其他多余的文件，保持脚手架工程为如下结构： 再次启动工程：1$ npm start 访问登录页http://localhost:3000/login，显示： 访问注册页http://localhost:3000/register，显示： 安装Chrome扩展访问Chrome的获取更多扩展程序 （可能要翻墙）。搜索安装react-developer-tools和redux-devtools。 或者自己去网上下载扩展程序的crx文件，进入chrome扩展程序页面，勾选开发者模式，然后把crx文件拖进去。 也不必刻意学习要怎么使用，开发中自己调出来，多点几下就都明白了。 按需安装其他库其他库，视自身项目情况安装吧。比如，如果你的后端使用node服务端暴露接口API，而你又使用express框架进行node开发。那么，你需要安装express： 1$ npm install express --save 假如你不想每次修改后端接口都重启node服务端，那么你可以安装nodemon库： 1$ npm install -g nodemon 安装了nodemon库后，用nodemon命令代替node命令启动node服务端就可以了。 安装node.js的消息体解析中间件：1$ npm install body-parser --save 假如你用cookie存储用户会话，可以安装node操作cookie的库cookie-parse： 1$ npm install cookie-parser --save 如果你要在node里用DM5进行密码加密的话，你可能需要utility库：1$ npm install utility --save 如果有实时聊天等功能的话，可能socket库你也需要： 1$ npm install socket.io --save 再如果，你是使用mongodb数据库，那么你要在机器上安装mongodb： 12345# mac电脑可以用brew工具在本机安装mongodb$ brew install mongodb# 完了后，你可以用以下命令启动和停止mongodb服务：$ brew services start mongodb$ brew services stop mongodb 安装mongoose库，封装了node对mongodb的api操纵： 1$ npm install mongoose --save npm里海量的库，自己按需安装去吧…… 源代码托管一下去github上创建下远程仓库react-redux-app。然后在工程目录下执行以下命令，关联上远程仓库：123$ git init$ git remote add origin https://github.com/zhutx/react-redux-app.git$ git push -u origin master]]></content>
      <categories>
        <category>React+Redux开发实录</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
</search>
