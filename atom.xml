<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhutx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-05T04:58:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhutx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>任务队列</title>
    <link href="http://yoursite.com/2018/04/17/rabbitmq/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/04/17/rabbitmq/任务队列/</id>
    <published>2018-04-17T07:31:21.000Z</published>
    <updated>2018-05-05T04:58:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一节我们描述了最简单的RabbitMQ操作，如何发送、接受消息。在这一节中我们将描述如何创建一个任务队列，来将高耗时的任务分发到多个消费者，从而提高处理效率。</p><a id="more"></a><p><img src="/uploads/rabbitmq/python-two.png" alt="任务队列"></p><p>任务队列最主要的功能就是把高耗时的操作交给队列，让它延后再做。我们将任务封装成一个消息发送给队列，后台的任务进程会得到这个任务并执行它，而且可以配置多个任务进程，进一步加大吞吐率。</p><p>我们用Thread.sleep()来假装有个繁忙的操作，用”.”来表示需要停顿的秒数，比如一个叫Hello…的任务将停顿3秒钟：</p><h1 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h1><p>为了确保消息不丢失，RabbitMQ支持消息确认。收到消息后消费者会给RabbitMQ服务器发送一个ack（我已经收到消息了），RabbitMQ就会在服务上删除这个消息了。</p><p>如果一个消费者挂了（连接关闭，channel关闭，或者是TCP连接丢失）而没有发送ack，RabbitMQ就会知道消息并没有消费成功，于是乎消息会被放到消息队列重新消费。如果此时还有其它消费者的话，消息会发送给其它消费者来消费，确保消息不会丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 关闭自动ACK机制</span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 收到消息后主动方ACK</span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h1 id="忘记应答"><a href="#忘记应答" class="headerlink" title="忘记应答"></a>忘记应答</h1><p>手动ack时，如忘记应答，导致unacked的消息无法释放，消息会一直被重发。（RabbitMQ内部维护了一个最大打开线程数，如果太多的消息没有应答，RabbitMQ甚至会崩溃）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看未应答消息数</span><br><span class="line">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br></pre></td></tr></table></figure><h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><p>光有ack应答机制还不够，RabbitMQ挂掉后，还是会丢失。因此我们还需要将消息持久化下来，当RabbitMQ重启时，队列以及消息也能够恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 队列持久化</span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 消息持久化</span><br><span class="line">AMQP.BasicProperties props = MessageProperties.PERSISTENT_TEXT_PLAIN;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, props, message.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><h1 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h1><p>当一个消费者非常耗时，而一个消费者非常快，由于消息都是公平的发送，所以它们都是接收到相同数量的消息，会导致一个消费者非常忙碌，而另外一个消费者非常空闲，而RabbitMQ无法得知这一点。</p><p>为了解决这个缺陷, 引入了basicQos方法以及prefetchCount =1的设置。这会告诉RabbitMQ一次只给消费者一个消息：如果这个消息未确认，将不会发送新的消息，从而它会将消息发送给其它并不那么忙的消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure><h1 id="整合代码"><a href="#整合代码" class="headerlink" title="整合代码"></a>整合代码</h1><ul><li>消息发送者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> durable = <span class="keyword">true</span>; <span class="comment">// 队列持久化</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties props = MessageProperties.PERSISTENT_TEXT_PLAIN; <span class="comment">// 消息持久化</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, props, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = strings.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            words.append(delimiter).append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息接收者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"task_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">final</span> Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prefetchCount = <span class="number">1</span>; </span><br><span class="line">        channel.basicQos(prefetchCount); <span class="comment">// 打破公平分发</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doWork(message);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">" [x] Done"</span>);</span><br><span class="line">                    <span class="comment">// 给RabbitMQ服务器发送ack，确认消息已收到</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 关闭自动消息确认机制, 消费者收到消息后需手动发给RabbitMQ服务器发ack</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : task.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 对每一个"."停顿1秒，假装很忙</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跑起来</strong></p><p>首先，让我们同时运行两个工作线程，他们能够同时从队列获取消息。我们也需要同时开启3个console：1个生产者，2个消费者</p><p>消费者C1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> shell 1</span><br><span class="line">java -cp $CP Worker</span><br><span class="line"><span class="meta">#</span> =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>消费者C2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> shell 2</span><br><span class="line">java -cp $CP Worker</span><br><span class="line"><span class="meta">#</span> =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>让我们运行生产者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> shell 3</span><br><span class="line">java -cp $CP NewTask</span><br><span class="line"><span class="meta">#</span> =&gt; First message.</span><br><span class="line">java -cp $CP NewTask</span><br><span class="line"><span class="meta">#</span> =&gt; Second message..</span><br><span class="line">java -cp $CP NewTask</span><br><span class="line"><span class="meta">#</span> =&gt; Third message...</span><br><span class="line">java -cp $CP NewTask</span><br><span class="line"><span class="meta">#</span> =&gt; Fourth message....</span><br><span class="line">java -cp $CP NewTask</span><br><span class="line"><span class="meta">#</span> =&gt; Fifth message.....</span><br></pre></td></tr></table></figure><p>让我们看看消费者们<br>消费者C1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP Worker</span><br><span class="line"><span class="meta">#</span> =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Received 'First message.'</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Received 'Third message...'</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Received 'Fifth message.....'</span><br></pre></td></tr></table></figure><p>消费者C2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP Worker</span><br><span class="line"><span class="meta">#</span> =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Received 'Second message..'</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Received 'Fourth message..</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一节我们描述了最简单的RabbitMQ操作，如何发送、接受消息。在这一节中我们将描述如何创建一个任务队列，来将高耗时的任务分发到多个消费者，从而提高处理效率。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>交换机</title>
    <link href="http://yoursite.com/2018/04/17/rabbitmq/%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/04/17/rabbitmq/交换机/</id>
    <published>2018-04-17T07:31:21.000Z</published>
    <updated>2018-05-05T04:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p><strong>什么是交换机</strong></p><p>rabbitmq的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。是append到一定规则的queue，还是append到多个queue中，还是被丢弃？这些规则都是通过exchagne的4种type去定义的。</p><a id="more"></a><p>exchange是一个消息的agent，每一个虚拟的host中都有定义。它的职责是把message路由到不同的queue中。</p><p><strong>binding</strong></p><p>exchange和queue通过routing-key关联，这两者之间的关系是就是binding。如下图所示,X表示交换机，红色表示队列，交换机通过一个routing-key去binding一个queue。</p><p><img src="/uploads/rabbitmq/binding.png" alt="binding"></p><p><strong>交换机类型</strong></p><ul><li>Default Exchange（默认交换机）</li><li>Fanout Exchange（广播交换机）</li><li>Directed Exchange（直连交换机）</li><li>Topic Exchange（主题交换机）</li></ul><h2 id="默认交换机"><a href="#默认交换机" class="headerlink" title="默认交换机"></a>默认交换机</h2><p>在前面的章节中虽然没有设置任何交换机，但依然能够将消息发送到队列，这是因为使用了默认交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p>第一个参数exhange为空字符串，即采用默认交换机，第二个参数routingKey定义了绑定的队列。</p><h2 id="广播交换机"><a href="#广播交换机" class="headerlink" title="广播交换机"></a>广播交换机</h2><p>为了更好的阐述这个模式，我们会建立一个简单的logging系统，包含2个步骤-第一步发送log信息，第二步能够接受并将信息打印出来，而且在第二步中所有的消费者都会接受到同样的消息，比如一个消费者用来将log信息写到磁盘，另外一个接受信息并显示在屏幕上。因此一旦有有消息，消息会广播到所有的消费者。</p><p><strong>生产者侧的变化</strong></p><p>使用广播交换机模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br></pre></td></tr></table></figure><p>广播模式无需进行队列的路由，会忽略routingKey，因此写空字符串即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><p><strong>消费者侧的变化</strong></p><p>使用广播交换机模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br></pre></td></tr></table></figure><p><strong>临时队列</strong></p><p>我们之前队列都有名字（Hello队列和task_queue队列)，给队列起名字非常重要-需要将消费者绑定到特定的queue上面，以及需要把消息从生产者发送给特定的消费者。</p><p>但对于日志来说，消息会发送到所有的消费者，而并非个别，为了满足当前需求我们用RabbitMQ随机分配队列，比如amq.gen-JzTY20BRgKO-HjmUJj0wLg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个不需要持久化、独立的、能够被自动删除的队列</span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p><strong>交换机和队列绑定</strong></p><p>我们已经声明了一个广播交换机，现在需要告诉这个交换机需要把信息发送给哪些队列，交换机和队列间的这个关系就称之为绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 广播模式无需进行队列的路由，会忽略routingKey，因此写空字符串即可</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p><strong>整合</strong></p><p>生产者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"info: Hello World!"</span>;</span><br><span class="line">        <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = strings.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            words.append(delimiter).append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp $CP EmitLog.java ReceiveLogs.java</span><br></pre></td></tr></table></figure><p>如果你希望将log存储到本机上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP ReceiveLogs &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>如果你希望在屏幕上显示log信息，打开一个新的终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP ReceiveLogs</span><br></pre></td></tr></table></figure><p>发送消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP EmitLog</span><br></pre></td></tr></table></figure><h2 id="直达交换机"><a href="#直达交换机" class="headerlink" title="直达交换机"></a>直达交换机</h2><p>上一节我们建立了一个简单的日志系统，从而将log消息广播给消费者。</p><p>现在我们希望通过log的严重程度进行过滤，例如只有严重的错误才会写入到磁盘，而warn和info消息就不用了，以此来节省磁盘空间。而广播交换机没法满足这个需求，它只是无脑的发送消息。所以我们会使用直达交换机(Direct Exchange)- 消息会通过所绑定的键来发送给对应的队列。</p><hr><p><img src="/uploads/rabbitmq/direct.png" alt="direct"></p><p>如上图所示，直达交换机X绑定了两个队列，C1是通过orange来绑定，而C2是通过black和green绑定。因此，发送到路由键orange的消息会发送给队列Q1，发送到路由键black或者green的消息会发送给Q2，其它的消息将被丢弃。</p><p><strong>多项绑定</strong></p><p><img src="/uploads/rabbitmq/mulibind.png" alt="mulibind"></p><p>当然，多个队列绑定到一个键上也是合法的，在这种情况下，直达交换机将会将消息发送给所有的队列，就像广播交换机一样，如上图所示，一个键为black的消息将会同时被发送给C1和C2。</p><p>首先生产者这一侧，需要创建一个直达交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br></pre></td></tr></table></figure><p>并发送消息到这个交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure><p>上面我们是发送给’severity’,简单起见，假设有下列几种日志类型’severity’ ,‘info’, ‘warning’, ‘error’。</p><p>消费者一侧，接受消息跟之前一样，但有一点不同，我们提供了一个binding key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String severity : argv)&#123;</span><br><span class="line">  channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整合</strong></p><p><img src="/uploads/rabbitmq/direct2.png" alt="direct2"></p><p>生产者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        String severity = getSeverity(argv);</span><br><span class="line">        String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + severity + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getSeverity</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"info"</span>;</span><br><span class="line">        <span class="keyword">return</span> strings[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = strings.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; startIndex ) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[startIndex]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            words.append(delimiter).append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: ReceiveLogsDirect [info] [warning] [error]"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String severity : argv)&#123;</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, severity);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + envelope.getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp $CP ReceiveLogsDirect.java EmitLogDirect.java</span><br></pre></td></tr></table></figure><p>只保存warning和error的消息到磁盘上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP ReceiveLogsDirect warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><p>将所有的消息打印到频幕上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP ReceiveLogsDirect info warning error</span><br><span class="line"><span class="meta">#</span> =&gt; [*] Waiting for logs. To exit press CTRL+C</span><br></pre></td></tr></table></figure><p>最后，发送error消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp $CP EmitLogDirect error "Run. Run. Or it will explode."</span><br><span class="line"><span class="meta">#</span> =&gt; [x] Sent 'error':'Run. Run. Or it will explode.'</span><br></pre></td></tr></table></figure><h2 id="主题交换机"><a href="#主题交换机" class="headerlink" title="主题交换机"></a>主题交换机</h2><p>在之前我们改进了日志系统。我们摒弃无脑发送消息的广播路由器，而使用能够根据绑定键(binding key)来发送消息的，从而能有有选择的后去logs.</p><p>尽管使用直达路由器大大的改进了我们系统，但也存在局限性:无法加入更多条件。比如我们希望能够加入更多的维度，我们希望不仅是基于严重程度，而且是基于来源，如果你对linux tool工具有了解的话，它不仅仅是基于严重程度(info/warn/crit…) 而且有来源(auth/cron/kern…)，会给我们更大的灵活性-我们需要监听所有来自’cron’的errors消息，以及来自’kern’的所有log。所以我们需要的是一个更复杂的<strong>主题交换机</strong></p><p><strong>主题交换机</strong></p><p>发送到主题交换机的消息并不会有一个确定的路由键-而是一长串字符列表，以”.“来分割，而这个字符串列表表明了路由信息，比如”stock.usd.nyse”，“nyse.vmw”，“quick.orange.rabbit”，字符串的最大长度限制在255bytes。</p><p>同时，在队列绑定交换机时也需要指定<strong>模式</strong>，而符合模式的消息将会被发送至该队列，模式可以由通配符组成：<br>‘*’ 可以表示一个词<br>‘#’ 表示0个或多个词<br>可以通过如下的例子来说明</p><p><img src="/uploads/rabbitmq/topic.png" alt="topic"></p><p>请看例子，以发送动物的消息为例，我们会发送包含三个词的路由键(两个”.”)。第一个是<strong>速度</strong>，第二个是<strong>颜色</strong>，而第三个是<strong>种族</strong></p><p>同时，我们建立了三个绑定，Q1绑定了键”<em>.orange.</em>“，Q2绑定了键”<em>.</em>.rabbit”以及”lazy.#”。可以做如下的解释，Q1用来接受所有orange的动物，Q2用来接受所有rabbits，以及lazy的动物</p><p>一个路由为”quick.orange.rabbit”的消息将会被同时发送给这两个队列，消息”lazy.orange.elephant”也会被同时发给它们；”quick.orange.fox”只会发给第一个队列；”lazy.brown.fox”会发到第二个；”lazy.pink.rabbit”将只会发送给第二个;”quick.brown.fox”会被丢弃因为匹配不上任何一个。</p><p>如果我们发送四个词的呢？比如”oragne”或者”quick.orange.male.rabbit”?这些没有任何匹配的队列将会丢失。但比如”quick.orange.male.rabbit”会匹配到第二个队列。</p><p>主题交换机也可以当成其它交换机来使用，假如队列绑定到了 “#”,那么它会接收所有的消息，就像广播路由器一样；而如果未使用”*“,”#”，那么就跟直达路由器一样了。</p><p><strong>整合代码</strong></p><p>生产者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">            factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">            connection = factory.newConnection();</span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            String routingKey = getRouting(argv);</span><br><span class="line">            String message = getMessage(argv);</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + routingKey + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>  (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRouting</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"anonymous.info"</span>;</span><br><span class="line">        <span class="keyword">return</span> strings[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">return</span> joinStrings(strings, <span class="string">" "</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = strings.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> ) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; startIndex ) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[startIndex]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            words.append(delimiter).append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Usage: ReceiveLogsTopic [binding_key]..."</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String bindingKey : argv) &#123;</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + envelope.getRoutingKey() + <span class="string">"':'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;交换机&quot;&gt;&lt;a href=&quot;#交换机&quot; class=&quot;headerlink&quot; title=&quot;交换机&quot;&gt;&lt;/a&gt;交换机&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是交换机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rabbitmq的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。是append到一定规则的queue，还是append到多个queue中，还是被丢弃？这些规则都是通过exchagne的4种type去定义的。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="http://yoursite.com/2018/04/17/rabbitmq/HelloWorld/"/>
    <id>http://yoursite.com/2018/04/17/rabbitmq/HelloWorld/</id>
    <published>2018-04-17T07:31:21.000Z</published>
    <updated>2018-05-05T04:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列，用来解耦系统模块。RabbitMQ完全实现了AMQ标准，与Kafka的快快快不同，它追求稳定、可靠。下面的介绍内容借鉴至RabbitMQ的官方文档。</p><p>RabbitMQ是一个消息的中介，就像是一个非常可靠的邮局，当信件放到邮局时，信件就确保能到达。</p><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li>producer（生产者）生产数据</li></ul><p><img src="/uploads/rabbitmq/producer.png" alt="生产者"></p><ul><li>queue（队列）存储消息，类似于邮箱</li></ul><p><img src="/uploads/rabbitmq/queue.png" alt="队列"></p><ul><li>Consumer（消费者）接收并消费消息</li></ul><p><img src="/uploads/rabbitmq/consumer.png" alt="消费者"></p><h1 id="HelloWorld示例"><a href="#HelloWorld示例" class="headerlink" title="HelloWorld示例"></a>HelloWorld示例</h1><p>下面我们用最简单的示例，完成消息的生产和消费：</p><p><img src="/uploads/rabbitmq/python-one.png" alt="helloworld"></p><ul><li>引入Maven依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>消息发送者：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ConnectionFactory产生一个新的连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建Channel 消息的产生和发送都是通过Channel完成的</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">        String message = <span class="string">"Hello World"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span>+ message +<span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后要关闭Channel</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息接受者：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rece</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过ConnectionFactory产生一个新的连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建Channel 消息的产生和发送都是通过Channel完成的</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" [*] Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息的发送是异步的，提供回调方法</span></span><br><span class="line">        <span class="comment">// DefaultConsumer会暂存异步消息, 直到消费者有能力来消费它</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>跑起来</strong></p><p>需要在生产者之前启动消费者，确保在消费消息之前这个队列是已经存在的</p><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp amqp-client-4.0.2.jar Send.java Recv.java</span><br></pre></td></tr></table></figure><p>而后来运行它，这需要我们在路径加上它的依赖包，我们首先启动的是消费者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .:amqp-client-4.0.2.jar:slf4j-api-1.7.21.jar:slf4j-simple-1.7.22.jar Recv</span><br></pre></td></tr></table></figure><p>而后启动发送者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .:amqp-client-4.0.2.jar:slf4j-api-1.7.21.jar:slf4j-simple-1.7.22.jar Send</span><br></pre></td></tr></table></figure><p>消费者会持续等待，并打印从生产者哪里来的消息，你可以用(Ctrl-C)来停止它。所以你要另外开启一个命令行窗口来运行生产者。</p><h1 id="查看队列"><a href="#查看队列" class="headerlink" title="查看队列"></a>查看队列</h1><p>也许你想知道RabbitMQ中到底有多少个消息，你可以使用rabbitmqctl工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列，用来解耦系统模块。RabbitMQ完全实现了AMQ标准，与Kafka的快快快不同，它追求稳定、可靠。下面的介绍内容借鉴至RabbitMQ的官方文档。&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个消息的中介，就像是一个非常可靠的邮局，当信件放到邮局时，信件就确保能到达。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>运维相关</title>
    <link href="http://yoursite.com/2018/04/17/rabbitmq/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2018/04/17/rabbitmq/运维相关/</id>
    <published>2018-04-17T07:31:21.000Z</published>
    <updated>2018-05-05T04:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看队列"><a href="#查看队列" class="headerlink" title="查看队列"></a>查看队列</h1><p>也许你想知道RabbitMQ中到底有多少个消息，你可以使用rabbitmqctl工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="忘记应答"><a href="#忘记应答" class="headerlink" title="忘记应答"></a>忘记应答</h1><p>很容易犯忘记应答的错误，但会导致非常严重的后果。Messages会被重发，RabbitMQ会消耗越来越多的内存因为unacked的消息无法释放（甚至更严重，RabbitMQ内部维护了一个最大打开线程数，如果太多的消息没有应答，RabbitMQ甚至会整个崩溃掉）</p><p>你可以用rabbitmqctl查看未被应答的消息数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues name messages_ready      </span><br><span class="line">messages_unacknowledged</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看队列&quot;&gt;&lt;a href=&quot;#查看队列&quot; class=&quot;headerlink&quot; title=&quot;查看队列&quot;&gt;&lt;/a&gt;查看队列&lt;/h1&gt;&lt;p&gt;也许你想知道RabbitMQ中到底有多少个消息，你可以使用rabbitmqctl工具：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo rabbitmqctl list_queues&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>（二）React技术栈一览</title>
    <link href="http://yoursite.com/2018/04/15/react-redux/React%E6%8A%80%E6%9C%AF%E6%A0%88%E4%B8%80%E8%A7%88/"/>
    <id>http://yoursite.com/2018/04/15/react-redux/React技术栈一览/</id>
    <published>2018-04-15T04:54:16.000Z</published>
    <updated>2018-04-15T10:47:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>从上面搭建工程脚手架中，我们看到了React开发技术栈。有ES6、babel、eslint、webpack、react、redux、react-router。</p><p>对React新手（有HTML、JavaScript、CSS基础）来说，需明确掌握React和Redux相关概念。至于其他的，了解就可以。不过我们有必要在实践之前从整体上俯瞰一下。清楚来龙去脉，避免迷迷糊糊一味跟随别人的代码去Ctrl+C &amp; Ctrl+V，即痛苦又容易半途而废。</p><a id="more"></a><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>JavaScript的下一代标准，规定今后按年份发布新版。2015年发布的ECMAScript6.0，也叫ES2015。<br>实践React之前，建议先了解下ES6的模块化、箭头函数、表达式解构、Promise异步编程。</p><p>完整了解ES6，推荐阅读前端大牛Nicholas C. Zakas（尼古拉斯.泽卡斯）的《深入理解ES6》</p><p>线上阅读推荐：阮一峰的开源书<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript6入门》</a></p><h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><p>JavaScript在不断发展，各种新的标准提案层出不穷，由于浏览器的多样性导致可能几年之内都无法广泛普及。<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个广泛使用的转码器，可以将ES6代码转化为几乎所有浏览器都认识的ES5旧代码，你可以不必顾虑的使用ES新特性。</p><p>这里有个Babel的<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL线上编译器</a>。在左侧输入箭头函数f=&gt;f感受下吧。</p><p>实践React之前，知道有这么个东西就可以了。Webpack会在构建项目时自动调用Babel进行转换。</p><p>线上阅读推荐：<a href="https://segmentfault.com/a/1190000009909951" target="_blank" rel="noopener">React技术栈之Babel</a></p><h1 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h1><p>ESLint是一个JavaScript代码静态检查工具，可以有效提高代码质量。维持前端团队高度一致的编码风格。ESLint不但提供一些默认的规则，也提供用户自定义规则去约束JavaScript风格。</p><p>ESLint是Nicholas C. Zakas（尼古拉斯.泽卡斯）创造的。前端大牛，前雅虎前端技术主管，YUI 库的贡献者。当年的我，凭着他的红宝书《JavaScript高级程序设计》，再配合《CSS网站布局实录》，就迈入前端。他同时也是《编写可维护的JavaScript》、《高性能JavaScript》和《深入理解ES6》的作者。</p><p>实践React之前，知道有这么个东西就可以了。项目过程中，需要调整规则的时候，参考<a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">ESlint完整规则列表</a></p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>Webpack是新一代打包工具。如今，前端项目日渐复杂，构建系统已成为开发过程中不可或缺的部分，而模块打包正是前端构建系统的核心。</p><p>实践React之前，了解下webpack就可以。通过ceate-react-app创建的脚手架，执行npm run eject弹出的webpack配置，就已经相当完美了。再集合项目，适当定制就可以了。</p><p>线上阅读推荐：<br><a href="https://segmentfault.com/a/1190000006178770" target="_blank" rel="noopener">入门webpack</a><br><a href="http://www.cnblogs.com/vajoy/p/4650467.html" target="_blank" rel="noopener">一小时包教会webpack</a></p><p>线上阅读推荐：<br><a href="https://segmentfault.com/a/1190000009902941" target="_blank" rel="noopener">React技术栈之Webpack环境搭建（一）手动搭建</a><br><a href="https://segmentfault.com/a/1190000009952845" target="_blank" rel="noopener">React技术栈之Webpack环境搭建（二）不同环境不同配置</a><br><a href="https://segmentfault.com/a/1190000010003262" target="_blank" rel="noopener">React技术栈之Webpack环境搭建（三）打包性能优化</a></p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React是Facebook推出的JavaScript库。口号是“用来创建用户界面的JavaScript库”，所以它只是和用户界面打交道，可以把它看成MVC中的V（视图）层，项目中一般再配上Redux进行数据流和状态的管理。</p><p>实践React之前，强烈建议熟悉下React概念。</p><p>线上阅读推荐：<br><a href="https://segmentfault.com/a/1190000009882841" target="_blank" rel="noopener">React技术栈之React（一）初识React</a><br><a href="https://segmentfault.com/a/1190000009921542" target="_blank" rel="noopener">React技术栈之React（二）组件的prop和state</a><br><a href="https://segmentfault.com/a/1190000009921634" target="_blank" rel="noopener">React技术栈之React（三）组件的生命周期</a></p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>React的核心就是组件，它只负责view，当应用复杂程度增加时，还需要有数据流向控制、状态管理等方案。</p><p>React推出了Flux架构及其官方实现。同时业界也推出了很多Flux的实现，其中以Redux为翘楚，它将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。</p><p>直接使用Redux是有点烦的，因此React官方提供了react-redux库，它对redux api进行了封装，借助react-redux，可以在项目中更方便的使用Redux。</p><p>实践React之前，必须熟悉Redux和react-redux，了解Flex架构更好但不是必须。</p><p>线上阅读推荐：<br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux入门教程</a><br><a href="https://segmentfault.com/a/1190000010112836" target="_blank" rel="noopener">React技术栈之Redux异步流</a><br><a href="https://segmentfault.com/a/1190000010205508" target="_blank" rel="noopener">React技术栈之Redux高阶运用</a></p><h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><p>路由库React-Router，是React体系的一个重要部分。它是官方维护的，事实上也是唯一可选的路由库。它通过管理URL，实现组件的切换和状态的变化。现在已经到了react-router4版本了，跟3版本用法有所不同。</p><p>实践React之前，可以了解下。</p><p>线上阅读参考：<br><a href="https://segmentfault.com/a/1190000009894639" target="_blank" rel="noopener">React技术栈之React-Router</a>(这个是react-router3)</p><h1 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h1><p>诸如 <a href="https://ant.design/index-cn" target="_blank" rel="noopener">Ant Design</a>、<a href="http://www.material-ui.com/" target="_blank" rel="noopener">Material-UI</a>、<a href="https://react-bootstrap.github.io/" target="_blank" rel="noopener">React bootstrap</a>、<a href="http://reactdesktop.js.org/" target="_blank" rel="noopener">React Desktop</a>、<a href="http://amazeui.org/react/" target="_blank" rel="noopener">Amaze UI React</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从上面搭建工程脚手架中，我们看到了React开发技术栈。有ES6、babel、eslint、webpack、react、redux、react-router。&lt;/p&gt;
&lt;p&gt;对React新手（有HTML、JavaScript、CSS基础）来说，需明确掌握React和Redux相关概念。至于其他的，了解就可以。不过我们有必要在实践之前从整体上俯瞰一下。清楚来龙去脉，避免迷迷糊糊一味跟随别人的代码去Ctrl+C &amp;amp; Ctrl+V，即痛苦又容易半途而废。&lt;/p&gt;
    
    </summary>
    
      <category term="React+Redux开发实录" scheme="http://yoursite.com/categories/React-Redux%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>（一）搭建工程脚手架</title>
    <link href="http://yoursite.com/2018/04/15/react-redux/%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/04/15/react-redux/搭建工程脚手架/</id>
    <published>2018-04-15T04:12:52.000Z</published>
    <updated>2018-04-15T06:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>安装node</li><li>安装git</li><li>安装一款前端IDE<br>推荐VSCode，最火的前端IDE，比sublime开源，比WebStrom轻，比XCode快。人性化，配色也很舒服，用来开发很惬意。</li></ul><a id="more"></a><h1 id="create-react-app基础脚手架"><a href="#create-react-app基础脚手架" class="headerlink" title="create-react-app基础脚手架"></a>create-react-app基础脚手架</h1><p>借助React官方的create-react-app工具，开发人员可以从配置工作中解脱出来，无需过早关注React技术栈，通过创建一个已经完成基本配置的应用，让开发者快速开始React应用的开发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>安装结束后，就可以在终端用create-react-app命令创建工程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app react-redux-app</span><br></pre></td></tr></table></figure><p>react-redux-app工程集成了react应用框架，在此基础上进行React应用开发，就避免了繁琐的初始配置工作。</p><p>进入工程目录，启动工程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> react-redux-app</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm start</span></span><br></pre></td></tr></table></figure><p>启动了一个开发模式的服务器，指向本机<a href="http://localhost:3000/，显示如下：" target="_blank" rel="noopener">http://localhost:3000/，显示如下：</a></p><p><img src="/uploads/react-redux/1.png" alt="clipboard.png"></p><h1 id="弹出webpack配置"><a href="#弹出webpack配置" class="headerlink" title="弹出webpack配置"></a>弹出webpack配置</h1><p>实际开发中，通常要定制webpack的配置，因此我们弹出应用的webpack配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm run eject</span></span><br></pre></td></tr></table></figure><p>执行完以上命令，react-redux-app下多了config和scrips目录，分别对应webpack配置和npm脚本。</p><h1 id="安装redux相关库"><a href="#安装redux相关库" class="headerlink" title="安装redux相关库"></a>安装redux相关库</h1><p>安装redux核心库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install redux --save</span></span><br></pre></td></tr></table></figure><p>直接使用redux的API会比较繁琐。react官方提供的react-redux库，可以更方便的使用redux：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install react-redux --save</span></span><br></pre></td></tr></table></figure><p>安装babel插件transform-decorators-legacy，可以使用@connect更方便的连接UI组件与容器组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-plugin-transform-decorators-legacy --save-dev</span></span><br></pre></td></tr></table></figure><p>安装transform-decorators-legacy插件后，需在package.json配置该插件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"babel": &#123;</span><br><span class="line">  "plugins": [</span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装下redux异步调用的库redux-thunk：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install redux-thunk --save</span></span><br></pre></td></tr></table></figure></p><h1 id="其他配套库"><a href="#其他配套库" class="headerlink" title="其他配套库"></a>其他配套库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 路由库react-router4</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install react-router-dom --save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ajax库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install axios --save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 组件属性校验库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install prop-types --save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cookie操纵库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install browser-cookies --save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> socket.io客户端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install socket.io-client --save</span></span><br></pre></td></tr></table></figure><h1 id="配置下代理"><a href="#配置下代理" class="headerlink" title="配置下代理"></a>配置下代理</h1><p>开发中，前端工程与后端API不在一个域名，为避免跨域限制，方便接口调试，需在package.json中配下代理：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 比如，任何ajax请求，都代理到localhost:9093域</span><br><span class="line">"proxy": "http://localhost:9093"</span><br></pre></td></tr></table></figure><h1 id="来一款CSS预处理器"><a href="#来一款CSS预处理器" class="headerlink" title="来一款CSS预处理器"></a>来一款CSS预处理器</h1><p>less、sass或stylus都行，这里我安装less。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install less-loader less --save-dev</span></span><br></pre></td></tr></table></figure></p><p>分别修改/config/webpack.config.dev.js和/config/webpack.config.prod.js：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(css|less)$/, //  这里加上less</span><br><span class="line">  use: [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      loader: require.resolve('less-loader') // 配置less-loader</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="配合一款UI框架"><a href="#配合一款UI框架" class="headerlink" title="配合一款UI框架"></a>配合一款UI框架</h1><p>React开发，国内首选蚂蚁金服的antd设计，移动端的话，安装antd-mobile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install antd-mobile --save-dev</span></span><br></pre></td></tr></table></figure><p>最好配置antd组件样式的按需加载，借助babel的import插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-plugin-import --save-dev</span></span><br></pre></td></tr></table></figure><p>package.json中，记得配置上该插件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"babel": &#123;</span><br><span class="line">  "plugins": [</span><br><span class="line">    "transform-decorators-legacy",</span><br><span class="line">    [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始目录文件"><a href="#初始目录文件" class="headerlink" title="初始目录文件"></a>初始目录文件</h1><p>创建一些初始目录和文件，在入口处完成redux和router的一些基础工作：</p><p>创建目录/src/component</p><p>创建目录/src/container</p><p>创建目录/src/redux</p><p>创建/src/container/login/index.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure><p>创建/src/container/register/index.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册页<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Register</span><br></pre></td></tr></table></figure><p>创建/src/config.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">'antd-mobile'</span></span><br><span class="line"></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    Toast.loading(<span class="string">'加载中'</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    Toast.hide()</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建/src/reducer.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;reducer&#125;)</span><br></pre></td></tr></table></figure><p>创建/src/app.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./container/login'</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">'./container/register'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Route path=<span class="string">"/Register"</span> component=&#123;Register&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">                &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><p>修改/src/index.js，编辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> registerServiceWorker <span class="keyword">from</span> <span class="string">'./registerServiceWorker'</span>;</span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./config'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line">registerServiceWorker()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers, compose(</span><br><span class="line">    applyMiddleware(thunk),</span><br><span class="line">    <span class="built_in">window</span>.devToolsExtension ? <span class="built_in">window</span>.devToolsExtension() : <span class="function"><span class="params">f</span> =&gt;</span> f</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">            &lt;App&gt;<span class="xml"><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>删除其他多余的文件，保持脚手架工程为如下结构：<br><img src="/uploads/react-redux/2.png" alt="clipboard.png"></p><p>再次启动工程：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm start</span></span><br></pre></td></tr></table></figure></p><p>访问登录页<a href="http://localhost:3000/login" target="_blank" rel="noopener">http://localhost:3000/login</a>，显示：</p><p><img src="/uploads/react-redux/3.png" alt="clipboard.png"></p><p>访问注册页<a href="http://localhost:3000/register" target="_blank" rel="noopener">http://localhost:3000/register</a>，显示：</p><p><img src="/uploads/react-redux/4.png" alt="clipboard.png"></p><h1 id="安装Chrome扩展"><a href="#安装Chrome扩展" class="headerlink" title="安装Chrome扩展"></a>安装Chrome扩展</h1><p>访问Chrome的<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">获取更多扩展程序</a> （可能要翻墙）。搜索安装react-developer-tools和redux-devtools。</p><p>或者自己去网上下载扩展程序的crx文件，进入<a href="chrome://extensions/" target="_blank" rel="noopener">chrome扩展程序</a>页面，勾选开发者模式，然后把crx文件拖进去。</p><p>也不必刻意学习要怎么使用，开发中自己调出来，多点几下就都明白了。</p><h1 id="按需安装其他库"><a href="#按需安装其他库" class="headerlink" title="按需安装其他库"></a>按需安装其他库</h1><p>其他库，视自身项目情况安装吧。比如，如果你的后端使用node服务端暴露接口API，而你又使用express框架进行node开发。那么，你需要安装express：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express --save</span></span><br></pre></td></tr></table></figure><p>假如你不想每次修改后端接口都重启node服务端，那么你可以安装nodemon库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g nodemon</span></span><br></pre></td></tr></table></figure><p>安装了nodemon库后，用nodemon命令代替node命令启动node服务端就可以了。</p><p>安装node.js的消息体解析中间件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install body-parser --save</span></span><br></pre></td></tr></table></figure></p><p>假如你用cookie存储用户会话，可以安装node操作cookie的库cookie-parse：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install cookie-parser --save</span></span><br></pre></td></tr></table></figure><p>如果你要在node里用DM5进行密码加密的话，你可能需要utility库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install utility --save</span></span><br></pre></td></tr></table></figure></p><p>如果有实时聊天等功能的话，可能socket库你也需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install socket.io --save</span></span><br></pre></td></tr></table></figure><p>再如果，你是使用mongodb数据库，那么你要在机器上安装mongodb：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac电脑可以用brew工具在本机安装mongodb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install mongodb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完了后，你可以用以下命令启动和停止mongodb服务：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start mongodb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services stop mongodb</span></span><br></pre></td></tr></table></figure><p>安装mongoose库，封装了node对mongodb的api操纵：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install mongoose --save</span></span><br></pre></td></tr></table></figure><p>npm里海量的库，自己按需安装去吧……</p><h1 id="源代码托管一下"><a href="#源代码托管一下" class="headerlink" title="源代码托管一下"></a>源代码托管一下</h1><p>去github上创建下远程仓库react-redux-app。<br>然后在工程目录下执行以下命令，关联上远程仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://github.com/zhutx/react-redux-app.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;安装node&lt;/li&gt;
&lt;li&gt;安装git&lt;/li&gt;
&lt;li&gt;安装一款前端IDE&lt;br&gt;推荐VSCode，最火的前端IDE，比sublime开源，比WebStrom轻，比XCode快。人性化，配色也很舒服，用来开发很惬意。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React+Redux开发实录" scheme="http://yoursite.com/categories/React-Redux%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
</feed>
